package com.example.randomdogapp.network

import android.util.Log
import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory

// реализация нашего сетевого клиента
// клиент является прослойкой между слоем отображения (или пользовательским интерфейсом) - MainActivity
// и между низкоуровнемым сетевым слоем.
// это сделано для того, чтобы отделить реализацию связанную с UI, от реализации, связанной с работой в сети интернет
class NetworkClient {
    // переменная для сервиса, именно с помощью этой переменной мы будет делать запросы к серверу
    private var service: DogApiService? = null
    // переменная, которой мы присваиваем экземпляр класса "логгера-перехватчика"
    // на самом деле, реализация класса HttpLoggingInterceptor позволяет ему "перехватывать" все наши запросы к серверу
    // и печатать информацию о них в Logcat. При это он не прерывает сам запрос.
    // Запрос выполнится или завершится неудачей вне зависимости от "логгера"
    private val logging: HttpLoggingInterceptor = HttpLoggingInterceptor()
        .setLevel(HttpLoggingInterceptor.Level.BODY) // устанавливаем

    // метод, который мы вызываем из MainActivity для того, чтобы настроить клиент
    fun initClient() {
        // создается переменная, которой мы присваевам экземпляр класса - то есть создаем клиент,
        // который поможет нам работать с http запросами
        // просттыми словами, OkHttp создаст сущность запроса, откроет интернет-соединение, отправит сам запрос и получит ответ
        // здесь и для Retrofit используется паттерн Builder для того чтобы не просто создать обьект, но еще и настроить его
        val httpClient: OkHttpClient.Builder
                = OkHttpClient.Builder()
        // добавляем нашему клиенту логгер-перехватчика
        httpClient.addInterceptor(logging)

        // создаем переменную, которой присвоем экземпляр класса Retrofit (используется паттерн Builder)
        // Retrofit поможет нам сгенерировать реализацию запросов по нашим инструкциям. Он помогает отличить успешный от неуспешного ответа,
        // собрать необходимые данные в запрос и отделить тело ответа от статуса и заголовков (headers)
        val retrofit = Retrofit.Builder()
            .baseUrl("https://dog.ceo/api/") // указывает адрес самого сервера
            .addConverterFactory(GsonConverterFactory.create()) // добавляем конвертер. Экземпляр класса GsonConverterFactory поможет нам "разложить" данные из json в экземпляр нашего data class. для создания экземпляра конвертера используется паттерн Factory
            .client(httpClient.build()) // указываем через какой клиент будут отправляться запросы
            .build()

        // именно с помощью кода ниже создается реализация запросов по нашим инструкциям, оставленным в DogApiService
        // эту реализацию мы присваеиваем в переменную service чтобы мы могли дальше с ней работать
        service = retrofit.create(DogApiService::class.java)

    }

    // метод для конкретного запроса - для получения адреса случайного изображения
    // здесь в параметрах функции мы используем callback - то есть метод обратного вызова.
    // то есть при вызове этого метода (из MainActivity) мы описываем какой-либо блок кода,
    // который начнет выполнения сразу после callback.invoke(..)
    fun getDog(callback: (String?) -> Unit) {
        // обращаемся к нашему сервису и указываем что нужно отправить запрос getRandomDog()
        // enqueue (..) мы используем как инструкцию для того, чтобы Retrofit сделал этот запрос асинхронно
        // это значит что когда мы отправим запрос, работа этого метода будет находится "в режиме ожидания"
        // (или можно рассматривать это как завершение) и возобновит работу только когда прийдет ответ или возникнет ошибка
        // при этом, пока этот метод "в режиме ожидания", остальные чати программы могут работать,
        // процессорное время будет свободно для выполнения других фрагментов кода
        service?.getRandomDog()?.enqueue(object : Callback<RandomDogAnswer> {
            // этот метод будет вызван клиентом в случае если запрос завершится успешно, например сервер вернет 200 ОК
            // раз запрос завершится удачно, значит у него могут быть полезные занные, которые мы можем получить из поля response
            // на этот момент Retrofit & OkHttp сделали за нас огромную работу и просто вернули результат, который мы ожидаем
            override fun onResponse(call: Call<RandomDogAnswer>, response: Response<RandomDogAnswer>) {
                // мы получаем из тела успешного ответа данные которые нам нужны и присваиваем результат в новую переменную
                val dogImageUrl = response.body()?.message
                // печатаем лог с данными в Logcat для проверки результата
                Log.i("DOG APP DEBUG", "the dog image address is $dogImageUrl")
                // вызываем callback и передаем туда адрес картинки, чтобы уже MainActivity разобралась что с ним делать дальше
                callback.invoke(dogImageUrl)
            }

            // этот метод будет вызван если сервер ответил ошибкой или если ошибка произошла во время
            // попытки отправить запрос или получить ответ. Например нет соединения с интернетом,
            // сервер слишком долго не отвечает или мы сформировали неправильный запрос
            override fun onFailure(call: Call<RandomDogAnswer>, error: Throwable) {
                // печатаем лог с пояснением о том, во время какого действия произошла ошибка и какая именно
                Log.e("DOG APP DEBUG", "It's an error while we were trying to get a dog image", error)
            }

        })
    }
}